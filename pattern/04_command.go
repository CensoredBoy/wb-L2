package main

import "fmt"

/*
Команда — это поведенческий паттерн, позволяющий заворачивать запросы или простые операции в отдельные объекты.

Это позволяет откладывать выполнение команд, выстраивать их в очереди, а также хранить историю и делать отмену.

Например, может использоваться для разделения слоя графического интерфейса,
от слоя бизнес-логики, которые будут общаться друг с другом посредством
объектов команд: отправитель (графический интерфейс) будет вызывать нужную команду,
а получатель (бизнес-логика) будет делать нужное действие.

Плюсы:
- Убирается прямая связь между отправителями и исполнителями запросов
- Позволяет удобно реализовывать различные операции: отмена и повтор запросов,
отложенный запуск запросов, выстраивание очереди запросов.
Минусы:
- Усложняет код из-за необходимости реализации дополнительных классов
*/

// Интерфейс команды
type Command interface {
	Execute()
}

//---------------------------------------------------------------------------------------

// Конкретная команда
type GoCommand struct {
	m Mover
}

func (c *GoCommand) Execute() {
	c.m.Go()
}

//---------------------------------------------------------------------------------------

// Конкретная команда
type StopCommand struct {
	m Mover
}

func (c *StopCommand) Execute() {
	c.m.Stop()
}

//---------------------------------------------------------------------------------------

// Интерфейс
type Mover interface {
	Go()
	Stop()
}

//Конкретный девайс - телевизор
//---------------------------------------------------------------------------------------
type Man struct {
}

func (m *Man) Go() {
	fmt.Println("I'm going")
}

func (m *Man) Stop() {
	fmt.Println("I'm standing")
}

//---------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------
type Invoker struct {
	commands []Command
}

func (i *Invoker) StoreCommand(command Command) {
	i.commands = append(i.commands, command)
}

func (i *Invoker) UnStoreCommand(command Command) {
	if len(i.commands) != 0 {
		i.commands = i.commands[:len(i.commands)-1]
	}
}

func (i *Invoker) Execute() {
	for _, command := range i.commands {
		command.Execute()
	}
}

//---------------------------------------------------------------------------------------

func main() {

	invoker := new(Invoker)
	var man Mover = new(Man)

	invoker.StoreCommand(&GoCommand{m: man})
	invoker.StoreCommand(&StopCommand{m: man})

 	invoker.Execute()
}
